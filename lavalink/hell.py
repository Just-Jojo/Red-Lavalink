(importer := __import__("importlib").import_module, asyncio := importer("asyncio"), aiohttp := importer("aiohttp"), enum := importer("enum"), discord := importer("discord"), types := importer("types"), collections := importer("collections"), logging := importer("logging"), secrets := importer("secrets"), string := importer("string"), redbot := importer("redbot"), log := logging.getLogger("red.core.LL"), ws_ll_log := logging.getLogger("red.Audio.WS.LLNode"), ws_rll_log := logging.getLogger("red.Audio.WS.RLL"), coro := lambda f: (y := types.coroutine(f), setattr(y, "__code__", (z := y.__code__).replace(co_flags=z.co_flags | 128)))[0], throw := (_ for _ in ()).throw, a_try := coro(lambda t, *a, f=lambda a: a, e=Exception, **kw: ([r for globals()["r"] in [{}]][0]).pop("r", (yield from (type("", (), {"__call__": lambda self, func: coro(lambda *a, **kw: (f := func(*a, **kw), (yield from _sem_wrapper(self, f)))[-1]), "__aenter__": coro(lambda self: self), "__aexit__": coro(lambda self, *a: isinstance(a[1], e) and [r.update(r=(yield from discord.utils.maybe_coroutine(f, a)))]),})()(t)(*a, **kw))))), s_try := lambda t, *a, f=lambda a:a, e=Exception, **k: ([r for globals()["r"] in [{}]][0]).pop("r", type("", (__import__("contextlib").ContextDecorator,), {"__enter__":int,"__exit__":lambda s,*a:isinstance(a[1], e) and [r.update(r=f(a))]})()(t)(*a, **k)), _nodes := [], PositionTime := collections.namedtuple("PositionTime", "position time connected"), MemoryInfo := namedtuple("MemoryInfo", "reservable used free allocated"), CPUInfo := namedtuple("CPUInfo", "cores systemLoad lavalinkLoad"), _event_listeners := [], _update_listeners := [], _stats_listeners := [], LavalinkEvents := enum.Enum("LavalinkEvents", {"TRACK_END": "TrackEndEvent", "TRACK_EXCEPTION": "TrackExceptionEvent", "TRACK_STUCK": "TrackStuckEvent", "TRACK_START": "TrackStartEvent", "WEBSOCKET_CLOSED": "WebsocketClosedEvent", "FORCED_DISCONNECT": "ForcedDisconnectEvent", "QUEUE_END": "QueueEndEvent"}), TrackEndReason := enum.Enum("TrackEndReason", {"FINISHED": "FINISHED", "LOAD_FAILED": "LOAD_FAILED", "STOPPED": "STOPPED", "REPLACED": "REPLACED", "CLEANUP": "CLEANUP"}), LavalinkIncomingOp := enum.Enum("LavalinkIncomingOp", {"EVENT": "event", "PLAYER_UPDATE": "playerUpdate", "STATS": "stats"}), LavalinkOutgoingOp := enum.Enum("LavalinkOutgoingOp", {"VOICE_UPDATE": "voiceUpdate", "DESTROY": "destroy", "PLAY": "play", "STOP": "stop", "PAUSE": "pause", "SEEK": "seek", "VOLUME": "volume"}), NodeState := enum.Enum("NodeState", {"CONNECTING": 0, "READY": 1, "RECONNECTING": 2, "DISCONNECTING": 3}), PlayerState := enum.Enum("PlayerState", {"CREATED": -1, "CONNECTING": 0, "READY": 1, "NODE_BUSY": 2, "RECONNECTING": 3, "DISCONNECTING": 4}), LoadType := enum.Enum("LoadType", {i: i for i in ("TRACK_LOADED", "PLAYLIST_LOADED", "SEARCH_RESULT", "NO_MATCHES", "LOAD_FAILED", "V2_COMPAT", "V2_COMPACT")}), ExceptionSeverity := enum.Enum("ExceptionSeverity", {i: i for i in ("COMMON", "SUSPICIOUS", "FAULT")}), RedLavalinkException := type("RedLavalink", (Exception,), {}), NodeException := type("NodeException", (RedLavalinkException,), {}), PlayerException := type("PlayerException", (RedLavalinkException,), {}), AbortingNodeConnection := type("AbortingNodeConnection", (NodeException,), {}), NodeNotReady := type("NodeNotReady", (NodeException,), {}), NodeNotFound := type("NodeNotFound", (NodeException,), {}), PlayerNotFound := type("PlayerNotFound", (PlayerException,), {}), initialize := coro(lambda bot, *, host, password, port=None, timeout=30, resume_key=None, resume_timeout=60, secured=False: (None, register_event_listener(_handle_event), register_update_listener(_handle_update), lavalink_node := Node(event_handler=dispatch, host=host, password=password, port=port, user_id=bot.user.id, num_shards=bot.shard_count or 1, resume_key=resume_key, resume_timeout=resume_timeout, bot=bot, secured=secured), (yield from lavalink_node.connect(timeout=timeout)), setattr(lavalink_node, "_retries", 0), bot.add_listener(_on_guild_remove, name="on_guild_remove"))[0]), connect := coro(lambda channel, deafen=False: (node := get_node(channel.guild.id), p := (yield from node.create_player(channel, deafen=deafen)), p)[-1]), get_player := lambda guild_id: (node := get_node(guild_id), node.get_player(guild_id))[-1], _on_guild_remove := coro(lambda guild: ((yield from a_try(coro(lambda: (p := get_player(guild.id), (yield from p.disconnect()))), f=lambda a:..., e=(NodeNotFound, PlayerNotFound))))), register_event_listener := lambda c: (throw(TypeError("Function is not a coroutine")) if not asyncio.iscoroutinefunction(c) else (_event_listeners.append(c) if c not in _event_listeners else ...)), _handle_event := coro(lambda player, data, extra: (yield from player.handle_event(data, extra))), _get_event_args := lambda data, raw_data: (guild_id := int(raw_data.get("guildId")), node_player := s_try(lambda: (get_node(guild_id, ignore_ready_status=True), get_player(guild_id)), f=lambda a: (log.debug("Got an event for a guild that we have no player for. This may because of a forced voice channel disconnect.") if data != LavalinkEvents.TRACK_END else ...), e=(NodeNotFound, PlayerNotFound)), (... if not node_player else (node := node_player[0], player := node_player[1], extra := None, (extra := TrackEndReason(raw_data.get("reason")) if data == LavalinkEvents.TRACK_END else (exception_data := raw_data["exception"], extra := {"message": exception_data["message"], "cause": exception_data["cause"], "severity": ExceptionSeverity(exception_data["severity"])})), (player, data, extra))[-1])), unregister_event_listener := lambda c: (s_try(lambda: _event_listeners.remove(c), f=lambda a: ..., e=ValueError)), register_update_listener := lambda c: (throw(TypeError("Function is not a coroutine.")) if not asyncio.iscoroutinefunction(c) else (_update_listeners.append(c) if c not in _update_listeners else ...)), _handle_update := coro(lambda player, data, raw_data: (yield from player.handle_player_update(data))), _get_update_args := lambda data, raw_data: (guild_id := int(raw_data.get("guildId")), player := s_try(lambda guild_id: get_player(guild_id), guild_id, f=lambda a: (log.debug("Got a player update for a guild that we have no player for. This may be because of a forced voice channel disconnect."), None)[-1], e=(NodeNotFound, PlayerNotFound)), ((player, data, raw_data) if player else None))[-1], unregister_update_listener := lambda c: (s_try(lambda: _update_listeners.remove(c), f=lambda a: ..., e=ValueError)), register_stats_listener := lambda c: (throw(TypeError("Function is not a coroutine.") if not asyncio.iscoroutinefunction(c) else (_stats_listeners.append(c) if c not in _stats_listeners else ...))), unregister_stats_listener := lambda c: s_try(lambda: _stats_listeners.remove(c), f=lambda a: ..., e=ValueError), dispatch := lambda op, data, raw_data: (listeners := [], args := [], ((listeners := _event_listeners, args := _get_event_args(data, raw_data)) if op == LavalinkIncomingOp.EVENT else ((listeners := _update_listeners, args := _get_update_args(data, raw_data)) if op == LavalinkIncomingOp.PLAYER_UPDATE else ((listeners := _stats_listeners, args := [data]) if op == LavalinkIncomingOp.STATS else ...))), ([asyncio.create_task(c(*args)) for c in listeners] if args is not None else ...)), close := coro(lambda bot: (log.debug("Closing Lavalink connections"), unregister_event_listener(_handle_event), unregister_update_listener(_handle_update), bot.remove_listener(_on_guild_remove, name="on_guild_remove"), (yield from disconnect()), log.debug("All lavalink nodes have been disconnected"))), all_players := lambda: tuple(p for n in _nodes for p in n.players), all_connected_players := lambda: tuple(p for n in _nodes for p in n.players if p.connected), active_players := lambda: (ps := all_connected_players(), tuple(p for p in ps if p.is_playing))[-1], wait_until_ready := coro(lambda *, timeout=None, wait_if_no_node=None: (yield from a_try(coro(lambda: ((yield from asyncio.sleep(1)) if not _nodes else throw(Exception("Break")) for _ in range(0, abs(wait_if_no_node), 1))), f=lambda a: ..., e=Exception) if wait_if_no_node is not None else ...), (throw(asyncio.TimeoutError) if not _nodes else ...), (throw(result) if result else ... for result in (yield from asyncio.gather(*(node_.wait_until_ready(timeout) for node_ in _nodes if (not node_.ready) and not node_.state == NodeState.DISCONNECTING), return_exceptions=True)))), _Key := type("_Key", (), {"__init__": lambda self, length=32: (None, setattr(self, "length", length), setattr(self, "persistent", ""), self.__repr__())[0], "__repr__": lambda self: (alphabet := string.ascii_letters + string.digits + "#$%&()*+,-./:;<=>?@[]^_~!", key := "".join(secrets.choice(alphabet) for _ in range(self.length)), setattr(self, "persistent", key), key)[-1], "__str__": lambda self: (self.__repr__() if not self.persistent else self.persistent)}), Stats := type("Stats", (), {"__init__": lambda self, memory, players, active_players, cpu, uptime: (None, setattr(self, "memory", MemoryInfo(**memory)), setattr(self, "players", players), setattr(self, "active_players", active_players), setattr(self, "cpu_info", CPUInfo(**cpu)), setattr(self, "uptime", uptime))[0]}), NodeStats := type("NodeStats", (), {"__init__": lambda self, data: (None, setattr(self, "uptime", data["uptime"]), setattr(self, "players", data["players"]), setattr(self, "playing_players", data["playingPlayers"]), memory := data["memory"], (setattr(self, f"memory_{k}", memory[k]) for k in ("free", "used", "allocated", "reservable")), cpu := data["cpu"], setattr(self, "cpu_cores", cpu["cores"]), setattr(self, "system_load", cpu["systemLoad"]), setattr(self, "lavalink_load", cpu["lavalinkLoad"]), frame_stats := data.get("frameStats", {}), (setattr(self, f"frame_{k}", frame_stats.get(k, -1)) for k in ("sent", "nulled", "deficit")))[0], "__repr__": lambda self: f"<NodeStats: uptime={self.uptime}, players={self.players}, playing_players={self.playing_players}, memory_free={self.memory_free}, memory_used={self.memory_used}, cpu_cores={self.cpu_cores}, system_load={self.system_load}, lavalink_load={self.lavalink_load}>"}), Node := type("Node", (), {"_is_shutdown": False, "__init__": lambda self, *, event_handler, host, password, user_id, num_shards, port=None, resume_key=None, resume_timeout=60.0, bot=None, secured=False: (None, setattr(self, "bot", bot), setattr(self, "event_handler", event_handler), setattr(self, "host", host), setattr(self, "secured", secured), setattr(self, "port", port if port is not None else (443 if self.secured else 80)), setattr(self, "password", password), setattr(self, "_resume_key", resume_key if resume_key else self._gen_key()), setattr(self, "_resume_timeout", resume_timeout), setattr(self, "_resuming_configured", False), setattr(self, "num_shards", num_shards), setattr(self, "user_id", user_id), setattr(self, "_ready_event", asyncio.Event()), setattr(self, "_ws", None), setattr(self, "_listener_task", None), setattr(self, "session", aiohttp.ClientSession()), setattr(self, "reconnect_task", None), setattr(self, "try_connect_task", None), setattr(self, "queue", []), setattr(self, "_players_dict", {}), setattr(self, "state", NodeState.CONNECTING), setattr(self, "_state_handlers", []), setattr(self, "_retries", 0), setattr(self, "stats", None), (_nodes.append(self) if self not in _nodes else ...), setattr(self, "_closers", (getattr(aiohttp.WSMsgType, x) for x in ("CLOSE", "CLOSED", "CLOSING"))), self.register_state_handler(self.node_state_handler))[0], "__repr__": lambda self: f"<Node: state={self.state}, host={self.host}, port={self.port}, password={'*' * len(self.password)}, resume_key={self._resume_key}, shards={self.num_shards}, user={self.user_id}, stats={self.stats}>", "headers": property(lambda self: self._get_connect_headers()), "players": property(lambda self: self._players_dict.values()), "guild_ids": property(lambda self: self._players_dict.keys()), "_gen_key": lambda self: (_Key() if self._resume_key is None else (self._resume_key.__repr__(), self._resume_key)[-1]), "connect": coro(lambda self, timeout=None, *, shutdown=False: (setattr(self, "_shutdown", shutdown), uri := f"ws{'s' if self.secured else ''}://{self.host}:{self.port}", ws_ll_log.info("Lavalink WS connecting to %s with headers %s", uri, self.headers), (self.try_connect_task.cancel() if self.try_connect_task is not None else ...), setattr(self, "try_connect_task", asyncio.create_task(self._multi_try_connect(uri))), (yield from a_try(coro(lambda: (yield from asyncio.wait_for(self.try_connect_task, timeout=timeout))), f=lambda: throw(AbortingNodeConnection), e=asyncio.CancelledError)))), "_configure_resume": coro(lambda self: (... if self._resuming_configured else ((yield from self.send(dict(op="configureResuming", key=str(self._resume_key), timeout=self._resume_timeout))), setattr(self, "_resuming_configured", True), ws_ll_log.debug("Node Resuming has been configured.")) if self._resume_key and self._resume_timeout and self._resume_timeout > 0 else ...)), "wait_until_ready": coro(lambda self, *, timeout=None: (yield from asyncio.wait_for(self._ready_event.wait(), timeout=timeout))), "_get_connect_headers": lambda self: (headers := {"Authorization": self.password, "User-Id": str(self.user_id), "Num-Shards": str(self.num_shards), "Client-Name": f"Red-Lavalink/{__version__}"}, (headers.__setitem__("Resume-Key", str(self._resume_key)) if self._resume_key else ...), headers)[-1], "lavalink_major_version": property(lambda self: (throw(NodeNotReady("Node not ready!")) if not self.ready else self._ws.response_headers.get("Lavalink-Major-Version"))), "ready": property(lambda self: self.state == NodeState.READY), "_multi_try_connect": coro(lambda self, uri: (backoff := discord.backoff.ExponentialBackoff(), attempt := 1, (self._listener_task.cancel() if self._listener_task is not None else ...), ((yield from self._ws.close(code=4006, message=b"Reconnecting")) if self._ws is not None else ...), ((setattr(self, "_retries", self._retries + 1), ((ws_ll_log.error("Lavalink node was shutdown during a connect attempt."), throw(asyncio.CancelledError)) if self._shutdown is True else ...), breaker := False, (yield from a_try(coro(lambda: (ws := (yield from self.session.ws_connect(url=uri, headers=self.headers, heartbeat=60)), ((ws_ll_log.error("Lavalink node was shutdown during a connect attempt."), throw(asyncio.CancelledError)) if self._shutdown is True else ...), setattr(self, "session_resumed", ws._response.headers.get("Session-Resumed", False)), (ws_ll_log.info("WEBSOCKET Resumed Session with key: %s", self._resume_key) if self._ws is not None and self.session_resumed else ...), setattr(self, "_ws", ws), breaker := True)), f=coro(lambda a: (exc := a[1], ((throw(asyncio.TimeoutError) if attempt > 5 else (delay := backoff.delay(), ws_ll_log.warning("Failed connect attempt %s, retrying in %s", attempt, delay), (yield from asyncio.sleep(delay)), attempt := attempt + 1)) if isinstance(exc, (OSError, aiohttp.ClientConnectionError)) else (ws_ll_log.error("Failed connect WSServerHandshakeError"), throw(asyncio.TimeoutError))))), e=(OSError, aiohttp.ClientConnectionError, aiohttp.WSServerHandshakeError)))) for _ in iter(lambda: (self._shutdown is False and (self._ws is None or self._ws.closed)) or breaker is True, True)), (throw(asyncio.CancelledError) if self._shutdown is True else ...), ws_ll_log.info("Lavalink WS connected to %s", uri), ws_ll_log.debug("Creating Lavalink WS listener."), ((setattr(self, "_listener_task", asyncio.create_task(self.listener())), asyncio.create_task(self._configure_resume), ((temp := self._queue.copy(), self._queue.clear(), [(yield from self.send(data)) for data in temp]) if self._queue else ...), self._ready_event.set(), self.update_state(NodeState.READY)) if self._is_shutdown is False else ...)))}))